# CVE-2018-20062

# §1 摘要



随便访问一个URL，在目标`Controller`类中打上断点，即可查看调用栈：

```mermaid
flowchart TB
	subgraph public_index.php["public/index.php"]
		public_index.php_require["require thinkphp/start.php"]
	end
	subgraph thinkphp_start.php["thinkphp/start.php"]
		thinkphp_start.php_App-run["think\App::run()"]
	end
	subgraph thinkphp_App.php["thinkphp/App.php"]
		subgraph thinkphp_App,php-run["\think\App::run()"]
			thinkphp_App.php-run-exec["$data=self::exec($dispatch,$config)"]
		end
		subgraph thinkphp_App.php-exec["\think\App::exec()"]
			thinkphp_App.php-exec-module["$data = self::module($dispatch['module'],$config,$dispatch['convert']??null])"]
		end
		subgraph thinkphp_App.php-module["\think\App::module()"]
			thinkphp_App.php-module-invokeMethod["return self::invokeMethod($call,$vars);"]
		end
		subgraph thinkphp_App.php-invokeMethod["\think\App::invokeMethod()"]
			thinkphp_App.php-invokeMethod-invokeArgs["return $reflect->invokeArgs($class??null,$args)"]
		end
	end
	subgraph application_index_controller_Index.php["application/index/controller/Index.php"]
		application_index_controller_Index.php-index["return $this->fetch();"]
	end
	public_index.php_require-->thinkphp_start.php_App-run
		-->thinkphp_App.php-run-exec
		-->thinkphp_App.php-exec-module
		-->thinkphp_App.php-module-invokeMethod
		-->thinkphp_App.php-invokeMethod-invokeArgs
		-->application_index_controller_Index.php-index
```

如果我们能操纵`invokeArgs()`中的`$class`参数，就能实例化任意类造成RCE了。

现在访问`locahost/blog/user/login`：

在`App`类的`self::exec()`方法中下断点，容易发现在此时ThinkPHP框架已经对Url完成分割了：

```php
$data = self::exec($dispatch,$config);
    // $dispatch = [
    //     'type'=>'module',
    //     'module'=>['blog','user','login']
    // ]
```

往前回顾，`$dispatch`变量第一次出现是在`App`实例中获取的：

```php
$dispatch = self::$dispatch; // null
if(empty($dispatch)){
	$dispatch = self::routeCheck($request,$config);
}
```

进一步跟踪`App::routeCheck()`的行为：

```php
$result = Route::parseUrl($path, $depr, $config['controller_auto_search']);
```

进一步跟踪`Route::parseUrl()`的行为：

```php
$url = str_replace($depr, '|', $url); // 把Url中所有的/换成|
list($path, $var) = self::parseUrlPath($url);
$route = [null, null, null];
```

进一步跟踪`Route::parseUrlPath($url)`的行为：

```php
private static function parseUrlPath($url) // $url = 'blog|user|login'
{
    // 分隔符替换 确保路由定义使用统一的分隔符
    $url = str_replace('|', '/', $url);
    $url = trim($url, '/');
    $var = [];
    if (false !== strpos($url, '?')) {
        // [模块/控制器/操作?]参数1=值1&参数2=值2...
        $info = parse_url($url);
        $path = explode('/', $info['path']);
        parse_str($info['query'], $var);
    } elseif (strpos($url, '/')) {
        // [模块/控制器/操作]
        $path = explode('/', $url);
    } else {
        $path = [$url];
    }
    return [$path, $var];
}
```

可以看到这里并没有过滤`\`，可以考虑使用PHP命名空间的特性传